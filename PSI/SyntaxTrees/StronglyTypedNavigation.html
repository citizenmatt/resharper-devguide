


<!doctype html>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <title> / ReSharper  DevGuide</title>
    <link rel="stylesheet" href="/resharper/devguide/app/css/styles.min.css">
<link  rel="stylesheet" href="/resharper/devguide/styles/styles.css"></head>
<body data-id="PSI/SyntaxTrees/StronglyTypedNavigation">
<div class="wrapper">
    <section class="panel _nav">
        <header class="panel__header">
            <div class="container">
                <form class="search-box">
                    <label for="search-box__input" class="search-box__label">
                        <input type="text" class="search-box__input" id="search-box__input" placeholder="Search ReSharper  DevGuide">
                    </label>
                    <div class="search-box__clear" title="Clear"></div>
                </form>
            </div>
        </header>
        <nav class="panel__content">
            <div class="container _nav">
                <menu class="nav-tree"></menu>
            </div>
            <div class="container _footer panel__footer">
                <p><a href="mailto:feedback@jetbrains.com">Send feedback</a></p>
                <p>&copy; 2000&ndash;2015 <a href="//www.jetbrains.com">JetBrains</a> s.r.o.<br>
                    All rights reserved.</p>
            </div>
        </nav>
    </section>

    <main class="panel _main" role="main">
        <header class="panel__header">
            <div class="container">
                <h3>ReSharper DevGuide</h3>
                
        <div class="shortcuts-switcher"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1">
            <option data-group="primary" value="default" selected>Default</option>
            <option data-group="primary" value="default_for_gnome">GNOME</option>
            <option data-group="primary" value="default_for_kde">KDE</option>
            <option data-group="primary" value="default_for_xwin">XWindow</option>
            <option data-group="primary" value="emacs">Emacs</option>
            <option data-group="primary" value="jbuilder">JBuilder</option>
            <option data-group="primary" value="visual_studio">Visual Studio</option>
            <option data-group="primary" value="netbeans_6.5">NetBeans 6.5</option>
            <option data-group="primary" value="eclipse">Eclipse</option>
            <option data-group="secondary" value="mac_os_x_10.5_">OS X 10.5+</option>
            <option data-group="secondary" value="mac_os_x">OS X</option>
            <option data-group="secondary" value="eclipse_mac_os_x">OS X Eclipse</option></select>
        </div>
    
                <div class="panel-trigger"></div>
            </div>
        </header>
        <section class="panel__content">
            <div class="container">
                <article class="article" data-shortcut-switcher="false">

                    
                    <a name="strongly-typed-navigation" class="elem-anchor"></a>
<h1>Strongly Typed Navigation<a href="#strongly-typed-navigation" class="anchor-link"><span></span></a></h1>

<p>While it’s possible to navigate a syntax tree using just the parent, sibling and child nodes, it’s a rather low level approach to the problem. If your current node is a class declaration, it’s a lot of leg work to get at all of the method declarations. Similarly, from a method declaration, it’s not convenient to walk the <code class="code highlight language-text">Parent</code> nodes looking for the class declaration.</p>

<p>Fortunately, ReSharper provides strongly typed navigation to make this a lot more convenient and intuitive.</p>

<a name="navigating-down-the-tree" class="elem-anchor"></a>
<h2>Navigating down the tree<a href="#navigating-down-the-tree" class="anchor-link"><span></span></a></h2>

<p>Navigating down to child nodes is made very easy by derived interfaces of <code class="code highlight language-text">ITreeNode</code>. All nodes in the tree implement <code class="code highlight language-text">ITreeNode</code>, and also derive from it to provide a strongly typed API. For example, C# method declarations implement <code class="code highlight language-text">IMethodDeclaration</code>, which itself derives from <code class="code highlight language-text">ITreeNode</code>. If we take a look at some of the members:</p>

<pre><code class="code-block__wrapper code-block _highlighted lang_csharp"><span class="k">public</span> <span class="k">interface</span> <span class="n">IMethodDeclaration</span> <span class="p">:</span> <span class="n">ITreeNode</span>
<span class="p">{</span>
  <span class="n">IAttributeSectionList</span> <span class="n">AttributeSectionList</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">ICSharpIdentifier</span> <span class="n">NameIdentifier</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">ITypeParameterOfMethodList</span> <span class="n">TypeParameterList</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
  <span class="c1">// [...snip...]</span>
<span class="p">}</span></code></pre>

<aside class="note">
  <p> This example over-simplifies the real implementation of <code class="code highlight language-text">IMethodDeclaration</code>. The real definition applies the Interface Segregation Principle and splits out more interfaces that can be reused, such as <code class="code highlight language-text">ICSharpParametersOwnerDeclaration</code> and <code class="code highlight language-text">ICSharpModifiersOwnerDeclaration</code> to allow other nodes that can also have parameters, or modifiers, or attributes, etc., to share interfaces. The intent here is to discuss the strongly typed accessors, rather than document <code class="code highlight language-text">IMethodDeclaration</code>.</p>
</aside>

<p>Each of these properties is a strongly typed accessor to get to the <code class="code highlight language-text">ITreeNode</code> that represents the attributes on the method, or the node that represents the method’s name. Internally, the nodes are found by walking down the tree, looking for nodes of a particular type. They are then downcast to the strongly typed, <code class="code highlight language-text">ITreeNode</code> derived interfaces.</p>

<a name="collections" class="elem-anchor"></a>
<h3>Collections<a href="#collections" class="anchor-link"><span></span></a></h3>

<p>Similarly, collections can be represented. Let’s take a look at a simplified class declaration:</p>

<pre><code class="code-block__wrapper code-block _highlighted lang_csharp"><span class="k">public</span> <span class="k">interface</span> <span class="n">IClassDeclaration</span> <span class="p">:</span> <span class="n">ITreeNode</span>
<span class="p">{</span>
  <span class="n">TreeNodeCollection</span><span class="p">&lt;</span><span class="n">IMethodDeclaration</span><span class="p">&gt;</span> <span class="n">MethodDeclarations</span> <span class="p">{</span><span class="k">get</span><span class="p">;}</span>
  <span class="n">TreeNodeEnumerable</span><span class="p">&lt;</span><span class="n">IMethodDeclaration</span><span class="p">&gt;</span> <span class="n">MethodDeclarationsEnumerable</span> <span class="p">{</span><span class="k">get</span><span class="p">;}</span>
  <span class="c1">// [...snip...]</span>
<span class="p">}</span></code></pre>

<p>Here we can see that a class has a collection of method declarations. It is represented in two ways, firstly as an instance of <code class="code highlight language-text">TreeNodeCollection&lt;T&gt;</code> and secondly as a <code class="code highlight language-text">TreeNodeEnumerable&lt;T&gt;</code>. Both can be iterated over using <code class="code highlight language-text">foreach</code>, or LINQ queries. The major difference is that <code class="code highlight language-text">TreeNodeCollection&lt;T&gt;</code> implements <code class="code highlight language-text">IList&lt;T&gt;</code>, while <code class="code highlight language-text">TreeNodeEnumerable&lt;T&gt;</code> only implements <code class="code highlight language-text">IEnumerable&lt;T&gt;</code>. This means that the <code class="code highlight language-text">MethodDeclarationsEnumerable</code> property is more lightweight that the <code class="code highlight language-text">MethodDeclarations</code> property, but at the cost of flexibility.</p>

<p>The <code class="code highlight language-text">MethodDeclarations</code> property creates a new instance of <code class="code highlight language-text">TreeNodeCollection&lt;T&gt;</code> each time it’s accessed. The child nodes are iterated up-front, and passed to the collection as an array. The collection provides all the features of an implementation of <code class="code highlight language-text">IList&lt;T&gt;</code> (although it is a read-only list), so it can be iterated sequentially or randomly. It also provides a number of optimised LINQ queries, such as <code class="code highlight language-text">Any</code>, <code class="code highlight language-text">Reverse</code> and <code class="code highlight language-text">ToList</code>.</p>

<p>The <code class="code highlight language-text">MethodDeclarationsEnumerable</code> property, however, simply creates an instance of <code class="code highlight language-text">TreeNodeEnumerable&lt;T&gt;</code> (again, each time it’s accessed), but the nodes are not collected until the enumerable is enumerated - it is lazily evaluated, and does not store the whole list. This makes it more efficient than <code class="code highlight language-text">TreeNodeCollection&lt;T&gt;</code>.</p>

<aside class="tip">
  <p> You should favour the enumerable version of a property unless you require the extra features that <code class="code highlight language-text">IList&lt;T&gt;</code> gives you.</p>
</aside>

<a name="navigating-up-the-tree" class="elem-anchor"></a>
<h2>Navigating up the tree<a href="#navigating-up-the-tree" class="anchor-link"><span></span></a></h2>

<p>ReSharper also provides a strongly typed means of navigating <em>up</em> the tree, which is preferable to manually walking up the chain of <code class="code highlight language-text">Parent</code> properties. Generally speaking, if a node exposes strongly typed accessors, there will be a complementary navigator class.</p>

<p>For example, the <code class="code highlight language-text">IXmlTag</code> node exposes a <code class="code highlight language-text">Header</code> property of type <code class="code highlight language-text">IXmlTagHeader</code>, providing us strongly typed navigation <em>down</em> the tree (from a node representing a complete xml tag to the node representing the opening part of the tag). The <code class="code highlight language-text">XmlTagNavigator</code> static class gives us the opposite - strongly typed navigation <em>up</em> to an <code class="code highlight language-text">IXmlTag</code> from various child nodes.</p>

<pre><code class="code-block__wrapper code-block _highlighted lang_csharp"><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">XmlTagNavigator</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">static</span> <span class="n">IXmlTag</span> <span class="nf">GetByTag</span><span class="p">(</span><span class="n">IXmlTag</span> <span class="n">tag</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">}</span>
  <span class="k">public</span> <span class="k">static</span> <span class="n">IXmlTag</span> <span class="nf">GetByTagHeader</span><span class="p">(</span><span class="n">IXmlTagHeader</span> <span class="n">header</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">}</span>
  <span class="k">public</span> <span class="k">static</span> <span class="n">IXmlTag</span> <span class="nf">GetByTagFooter</span><span class="p">(</span><span class="n">IXmlTagFooter</span> <span class="n">footer</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">}</span>
  <span class="k">public</span> <span class="k">static</span> <span class="n">IXmlTag</span> <span class="nf">GetByAttribute</span><span class="p">(</span><span class="n">IXmlAttribute</span> <span class="n">attribute</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>The classes follow a simple naming pattern. The navigator class is named after the node you’re trying to navigate <em>to</em>, and the name ends in the word <code class="code highlight language-text">Navigator</code>, e.g. <code class="code highlight language-text">XmlTagNavigator</code> is trying to navigate to an instance of <code class="code highlight language-text">IXmlTag</code>. The methods all being with <code class="code highlight language-text">GetBy</code> and finish with the type of the node that should be passed in. So, <code class="code highlight language-text">XmlTagNavigator.GetByAttribute</code> is trying to navigate to an <code class="code highlight language-text">IXmlTag</code>, from an <code class="code highlight language-text">IXmlAttribute</code>.</p>

<aside class="warning">
  <p> Navigating up the tree is not as simple as casting <code class="code highlight language-text">Parent</code> to the appropriate type. The navigator methods have specific knowledge of parent/child relationships, and can walk several nodes up the hierarchy to find the appropriate node. For example, C#’s <code class="code highlight language-text">ClassDeclarationNavigator</code> can navigate to the class declaration node from an <code class="code highlight language-text">IAttribute</code> node, skipping the attribute list, attribute section and section list nodes before reaching the class declaration node.</p>

  <p>Since ReSharper knows these relationships, it is recommended that you use navigator classes where possible, instead of walking the <code class="code highlight language-text">Parent</code> properties manually.</p>
</aside>

<p>It should also be pointed out that you can use the navigator classes in combination. For example, to get to a class declaration from an <code class="code highlight language-text">if</code> statement in a C# file:</p>

<pre><code class="code-block__wrapper code-block _highlighted lang_csharp"><span class="k">public</span> <span class="n">IClassDeclaration</span> <span class="nf">GetByIfStatement</span><span class="p">(</span><span class="n">IIfStatement</span> <span class="n">ifStatement</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">methodBody</span> <span class="p">=</span> <span class="n">BlockNavigator</span><span class="p">.</span><span class="n">GetByStatement</span><span class="p">(</span><span class="n">ifStatement</span><span class="p">);</span>
  <span class="kt">var</span> <span class="n">methodDeclaration</span> <span class="p">=</span> <span class="n">MethodDeclaratioNavigator</span><span class="p">.</span><span class="n">GetByBody</span><span class="p">(</span><span class="n">methodBody</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">ClassDeclarationNavigator</span><span class="p">.</span><span class="n">GetByMethodDeclaration</span><span class="p">(</span><span class="n">methodDeclaration</span><span class="p">);</span>
<span class="p">}</span></code></pre>

<p>It isn’t necessary to check for null before passing a node into the navigator classes - they explicitly allow null to be passed in, and will return null if it can’t find the appropriate parent.</p>


                    <div class="last-modified">
                        Last modified: 8 May 2015
                    </div>
                </article>

                <section class="disqus">
                    <div id="disqus_thread"></div>
                </section>
            </div>
        </section>
    </main>
</div>


<script data-main="/resharper/devguide/app/js/main.build" data-baseurl="/resharper/devguide/" src="/resharper/devguide/app/js/vendor/requirejs/require.js"></script>

</body>
</html>

