


<!doctype html>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <title> / ReSharper  DevGuide</title>
    <link rel="stylesheet" href="/resharper-devguide/app/css/styles.min.css">
<link  rel="stylesheet" href="/resharper-devguide/styles/styles.css"></head>
<body data-id="PSI/References/Substrings">
<div class="wrapper">
    <section class="panel _nav">
        <header class="panel__header">
            <div class="container">
                <form class="search-box">
                    <label for="search-box__input" class="search-box__label">
                        <input type="text" class="search-box__input" id="search-box__input" placeholder="Search ReSharper  DevGuide">
                    </label>
                    <div class="search-box__clear" title="Clear"></div>
                </form>
            </div>
        </header>
        <nav class="panel__content">
            <div class="container _nav">
                <menu class="nav-tree"></menu>
            </div>
            <div class="container _footer panel__footer">
                <p><a href="mailto:feedback@jetbrains.com">Send feedback</a></p>
                <p>&copy; 2000&ndash;2015 <a href="//www.jetbrains.com">JetBrains</a> s.r.o.<br>
                    All rights reserved.</p>
            </div>
        </nav>
    </section>

    <main class="panel _main" role="main">
        <header class="panel__header">
            <div class="container">
                <h3>ReSharper DevGuide</h3>
                
        <div class="shortcuts-switcher"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1">
            <option data-group="primary" value="default" selected>Default</option>
            <option data-group="primary" value="default_for_gnome">GNOME</option>
            <option data-group="primary" value="default_for_kde">KDE</option>
            <option data-group="primary" value="default_for_xwin">XWindow</option>
            <option data-group="primary" value="emacs">Emacs</option>
            <option data-group="primary" value="jbuilder">JBuilder</option>
            <option data-group="primary" value="visual_studio">Visual Studio</option>
            <option data-group="primary" value="netbeans_6.5">NetBeans 6.5</option>
            <option data-group="primary" value="eclipse">Eclipse</option>
            <option data-group="secondary" value="mac_os_x_10.5_">OS X 10.5+</option>
            <option data-group="secondary" value="mac_os_x">OS X</option>
            <option data-group="secondary" value="eclipse_mac_os_x">OS X Eclipse</option></select>
        </div>
    
                <div class="panel-trigger"></div>
            </div>
        </header>
        <section class="panel__content">
            <div class="container">
                <article class="article" data-shortcut-switcher="false">

                    
                    <a name="references-within-elements---substrings" class="elem-anchor"></a>
<h1>References within elements - substrings<a href="#references-within-elements---substrings" class="anchor-link"><span></span></a></h1>

<p>A reference doesn’t need to be applied to the complete range of an element - it doesn’t have to be the whole string in a string literal. Multiple references can be applied to different parts of a single element.</p>

<p>For example, a file path reference provider will create multiple references for substrings within the string, one for each file path segment. A reference which wishes to do this should implement the <code class="code highlight language-text">IReferenceWithinElement&lt;T&gt;</code> interface, where <code class="code highlight language-text">T</code> is the owning PSI tree node.</p>

<pre><code class="code-block__wrapper code-block _highlighted lang_csharp"><span class="k">public</span> <span class="k">interface</span> <span class="n">IReferenceWithinElement</span> <span class="p">:</span> <span class="n">IReference</span>
<span class="p">{</span>
  <span class="n">ITreeNode</span> <span class="n">Token</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">TreeTextRange</span> <span class="n">RangeWithin</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">interface</span> <span class="n">IReferenceWithinElement</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">IReferenceWithinElement</span>
  <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">class</span><span class="p">,</span> <span class="n">ITreeNode</span>
<span class="p">{</span>
  <span class="n">ElementRange</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">ElementRange</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>The constructor for <code class="code highlight language-text">ElementRange</code> takes in an instance of <code class="code highlight language-text">T</code> and the <code class="code highlight language-text">TreeTextRange</code> that is the range within the node that should be used for the reference. The range should be relative to the length of the owner node’s short name.</p>

<p>Instead of implementing the <code class="code highlight language-text">IReferenceWithinElement&lt;T&gt;</code> interface directly, you can derive from <code class="code highlight language-text">ReferenceWithinElementBase&lt;TOwner, TToken&gt;</code>, which provides most of the implementation for you. This class derives from <code class="code highlight language-text">TreeReferenceBase</code> but implements things a little differently.</p>

<aside class="note">
  <p> In the type signature for <code class="code highlight language-text">ReferenceWithinElementBase&lt;TOwner, TToken&gt;</code>, <code class="code highlight language-text">TOwner</code> is the owner of the reference, and <code class="code highlight language-text">TToken</code> is the node within the owner’s sub-tree that will be used for the reference region. For example, <code class="code highlight language-text">TOwner</code> can be <code class="code highlight language-text">ICSharpLiteralExpression</code> and <code class="code highlight language-text">TToken</code> would be <code class="code highlight language-text">ITokenNode</code>, and set to a value of <code class="code highlight language-text">ICSharpLiteralExpression.Literal</code>.</p>
</aside>

<p>The constructor takes in the two element nodes, and the relative <code class="code highlight language-text">TreeTextRange</code> of the range within the <code class="code highlight language-text">TToken</code> tree node parameter. The name of the reference, as returned by <code class="code highlight language-text">GetText</code> is the substring of the <code class="code highlight language-text">TToken</code> node defined by this range. The range of the reference comes from the relative tree range of the substring.</p>

<p><code class="code highlight language-text">ReferenceWithinElementBase</code> provides an implementation of the abstract <code class="code highlight language-text">ResolveWithoutCache</code>. It defers to the abstract <code class="code highlight language-text">GetReferenceSymbolTable</code>. However, after retrieving the symbol table, it applies filters returned from <code class="code highlight language-text">GetSymbolFilters</code>. This allows our implementation of <code class="code highlight language-text">GetReferenceSymbolTable</code> to be very straight forward - we can return the symbol table for a particular class, for example, and then use the filters to reduce it to appropriate candidates.</p>

<p>The core implementation of <code class="code highlight language-text">GetSymbolFilters</code> is held in <code class="code highlight language-text">GetCompletionFilters</code> which returns an empty list by default. To add functionality, return an array of filters, for example:</p>

<pre><code class="code-block__wrapper code-block _highlighted lang_csharp"><span class="k">return</span> <span class="k">new</span> <span class="n">ISymbolFilter</span><span class="p">[]</span>
<span class="p">{</span>
  <span class="k">new</span> <span class="nf">DeclaredElementTypeFilter</span><span class="p">(</span><span class="n">ResolveErrorType</span><span class="p">.</span><span class="n">NOT_RESOLVED</span><span class="p">,</span> <span class="n">CLRDeclaredElementType</span><span class="p">.</span><span class="n">ENUM_MEMBER</span><span class="p">),</span>
  <span class="n">IsPublicFilter</span><span class="p">.</span><span class="n">INSTANCE</span>
<span class="p">};</span></code></pre>

<p>These will create a filter that finds any enums, and returns <code class="code highlight language-text">ResolveErrorType.NOT_RESOLVED</code> if it can’t find anything. If it finds an enum, it then goes through the <code class="code highlight language-text">IsPublicFilter</code> instance, which checks that the declared element is public. If it can’t find a match, it returns <code class="code highlight language-text">ResolveErrorType.ACCESS_RIGHTS</code>. There are lots of implementations of <code class="code highlight language-text">ISymbolFilter</code> which can be sequenced together to filter down to the appropriate candidates.</p>

<p>The only other method that requires implementation (unless you wish to customise the class further) is <code class="code highlight language-text">BindToInternal</code>. The <code class="code highlight language-text">BindTo</code> methods are implemented, and call into <code class="code highlight language-text">BindToInternal</code>. This method can use the <code class="code highlight language-text">ReferenceWithinElementUtil.SetText</code> method to set the text in the substring of the node, by creating a new token, with a passed in token factory <code class="code highlight language-text">Func</code>, using the new text of the node. It also fixes up any other references that are attached to the original node.</p>

<p>However, there is additional housekeeping required when the change is happening in a file that can contain multiple PSI trees (e.g. HTML files can contain HTML, JS and CSS trees). In this case you should use either the <code class="code highlight language-text">HtmlReferenceWithTokenUtil.SetText</code> or <code class="code highlight language-text">JavaScriptReferenceWithTokenUtil.SetText</code> extension methods to affect the change, as they propogate the change to the other PSI trees. Both implementations are the same, and it would be a reasonable choice to always call these methods instead of <code class="code highlight language-text">ReferenceWithinElementUtil</code> directly.</p>

<aside class="note">
  <p> The change is propogated to the other PSI trees by virtue of adding a “cookie” to the current PSI transaction. The <code class="code highlight language-text">CreateCustomCookie</code> extension method is used to attach an object to the transaction’s list of “cookie” objects. When making the change, the code asks the PSI transaction if the cookie is set, and if so, propogates the changes to the other PSI files</p>
</aside>



                    <div class="last-modified">
                        Last modified: 8 May 2015
                    </div>
                </article>

                <section class="disqus">
                    <div id="disqus_thread"></div>
                </section>
            </div>
        </section>
    </main>
</div>


<script data-main="/resharper-devguide/app/js/main.build" data-baseurl="/resharper-devguide/" src="/resharper-devguide/app/js/vendor/requirejs/require.js"></script>

</body>
</html>

