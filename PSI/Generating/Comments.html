


<!doctype html>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <title> / ReSharper  DevGuide</title>
    <link rel="stylesheet" href="/resharper/devguide/app/css/styles.min.css">
<link  rel="stylesheet" href="/resharper/devguide/styles/styles.css"></head>
<body data-id="PSI/Generating/Comments">
<div class="wrapper">
    <section class="panel _nav">
        <header class="panel__header">
            <div class="container">
                <form class="search-box">
                    <label for="search-box__input" class="search-box__label">
                        <input type="text" class="search-box__input" id="search-box__input" placeholder="Search ReSharper  DevGuide">
                    </label>
                    <div class="search-box__clear" title="Clear"></div>
                </form>
            </div>
        </header>
        <nav class="panel__content">
            <div class="container _nav">
                <menu class="nav-tree"></menu>
            </div>
            <div class="container _footer panel__footer">
                <p><a href="mailto:feedback@jetbrains.com">Send feedback</a></p>
                <p>&copy; 2000&ndash;2015 <a href="//www.jetbrains.com">JetBrains</a> s.r.o.<br>
                    All rights reserved.</p>
            </div>
        </nav>
    </section>

    <main class="panel _main" role="main">
        <header class="panel__header">
            <div class="container">
                <h3>ReSharper DevGuide</h3>
                
        <div class="shortcuts-switcher"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1">
            <option data-group="primary" value="default" selected>Default</option>
            <option data-group="primary" value="default_for_gnome">GNOME</option>
            <option data-group="primary" value="default_for_kde">KDE</option>
            <option data-group="primary" value="default_for_xwin">XWindow</option>
            <option data-group="primary" value="emacs">Emacs</option>
            <option data-group="primary" value="jbuilder">JBuilder</option>
            <option data-group="primary" value="visual_studio">Visual Studio</option>
            <option data-group="primary" value="netbeans_6.5">NetBeans 6.5</option>
            <option data-group="primary" value="eclipse">Eclipse</option>
            <option data-group="secondary" value="mac_os_x_10.5_">OS X 10.5+</option>
            <option data-group="secondary" value="mac_os_x">OS X</option>
            <option data-group="secondary" value="eclipse_mac_os_x">OS X Eclipse</option></select>
        </div>
    
                <div class="panel-trigger"></div>
            </div>
        </header>
        <section class="panel__content">
            <div class="container">
                <article class="article" data-shortcut-switcher="false">

                    
                    <a name="generating-comments" class="elem-anchor"></a>
<h1>Generating Comments<a href="#generating-comments" class="anchor-link"><span></span></a></h1>

<p>Comments occupy a curious place within the ReSharper ecosystem. On the one hand, a comment may be a simple string encapsulated in a node of a physical tree. On the other hand, a comment preceding a method consist of valid XML that is subsequently represented as a proper data structure.</p>

<p>In this section, we’re going to talk about code comments, the ways in which they are represented and manipulated.</p>

<a name="basic-comments" class="elem-anchor"></a>
<h2>Basic Comments<a href="#basic-comments" class="anchor-link"><span></span></a></h2>

<p>Before we begin, the most important thing to realize is that <em>basic comments (as opposed to XML comments) are only part of the physical tree</em>, i.e., comments are available in the tree structure that is the result of lexing of the source code, but they are <em>not available</em> when dealing with the definitions that are the results of the parsing stage.</p>

<p>Consider the following declaration:</p>

<pre><code class="code-block__wrapper code-block _highlighted lang_csharp"><span class="k">class</span> <span class="nc">C</span>
<span class="p">{</span>
  <span class="c1">// this is a comment</span>
<span class="p">}</span></code></pre>

<p>From the lexical perspective, the class body can be treated essentially as a sequence of tokens such as a left curly brace, newline, and so on. The comment above is represented by an <code class="code highlight language-text">ICommentNode</code> structure with a <code class="code highlight language-text">type</code> of <code class="code highlight language-text">END_OF_LINE_COMMENT</code>. Were you to change the comment to <code class="code highlight language-text">/* this is a comment */</code>, its type would be <code class="code highlight language-text">C_STYLE_COMMENT</code>.</p>

<p>But how do you actually <em>get</em> an <code class="code highlight language-text">ICommentNode</code>? This depends on the type of the feature you’re workin on. For example, let’s say that you’re writing a context action which replaces any comment it finds with <code class="code highlight language-text">/* hello, world */</code>. This context action would then have its <code class="code highlight language-text">IsAvailable()</code> method defined as follows:</p>

<pre><code class="code-block__wrapper code-block _highlighted lang_csharp"><span class="k">public</span> <span class="kt">bool</span> <span class="nf">IsAvailable</span><span class="p">(</span><span class="n">IUserDataHolder</span> <span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">provider</span><span class="p">.</span><span class="n">TokenAfterCaret</span> <span class="k">is</span> <span class="n">ICommentNode</span><span class="p">;</span>
<span class="p">}</span></code></pre>

<p>The provider’s <code class="code highlight language-text">TokenBeforeCaret</code> and <code class="code highlight language-text">TokenAfterCaret</code> properties yield the tokens that appear before and after the caret in the file being edited. Detecting them is easy, but what about actually editing them?</p>

<p>The bad news is that you cannot just call some <code class="code highlight language-text">SetText()</code> method on a comment node and be done with it - instead, you need to create a brand new <code class="code highlight language-text">ICommentNode</code> and replace the old one. Thus, the implementation of <code class="code highlight language-text">ExecutePsiTransaction()</code> for our context action would look something like the following:</p>

<pre><code class="code-block__wrapper code-block _highlighted lang_csharp"><span class="k">protected</span> <span class="k">override</span> <span class="n">Action</span><span class="p">&lt;</span><span class="n">ITextControl</span><span class="p">&gt;</span> <span class="n">ExecutePsiTransaction</span><span class="p">(</span><span class="n">ISolution</span> <span class="n">solution</span><span class="p">,</span> <span class="n">IProgressIndicator</span> <span class="n">progress</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">factory</span> <span class="p">=</span> <span class="n">CSharpElementFactory</span><span class="p">.</span><span class="n">GetInstance</span><span class="p">(</span><span class="n">provider</span><span class="p">.</span><span class="n">PsiModule</span><span class="p">);</span>
  <span class="kt">var</span> <span class="n">oldComment</span> <span class="p">=</span> <span class="n">provider</span><span class="p">.</span><span class="n">TokenAfterCaret</span> <span class="k">as</span> <span class="n">ICommentNode</span><span class="p">;</span>
  <span class="kt">var</span> <span class="n">newComment</span> <span class="p">=</span> <span class="n">factory</span><span class="p">.</span><span class="n">CreateComment</span><span class="p">(</span><span class="s">&quot;/* hello, world */&quot;</span><span class="p">);</span>
  <span class="n">ModificationUtil</span><span class="p">.</span><span class="n">ReplaceChild</span><span class="p">(</span><span class="n">oldComment</span><span class="p">,</span> <span class="n">newComment</span><span class="p">);</span>
  <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
<span class="p">}</span></code></pre>

<p>In the above example, we use a <code class="code highlight language-text">CSharpElementFactory</code> to manufacture a brand new comment, then use <code class="code highlight language-text">ModificationUtil</code> to replace the old comment with the new one. If you wanted to simply get rid of the comment, you could use <code class="code highlight language-text">ModificationUtil.DeleteChild()</code> instead.</p>

<a name="xml-doc-comments" class="elem-anchor"></a>
<h2>XML Doc Comments<a href="#xml-doc-comments" class="anchor-link"><span></span></a></h2>

<p>Now, what would happen if you declared the comment as <code class="code highlight language-text">/// &lt;z&gt;this is a comment&lt;/z&gt;</code>? The end result in this case is that the comment has a type of <code class="code highlight language-text">DocComment</code>. A ‘doc comment’ is different though - unlike an ordinary comment, a doc comment is typically attached to a particular element of the ‘chemical’ tree, such as a class or class member (field, property, etc.). It’s also possible in certain cases for a doc comment to span <em>several</em> elements at once. Here is an example.</p>

<pre><code class="code-block__wrapper code-block _highlighted lang_csharp"><span class="k">class</span> <span class="nc">C</span>
<span class="p">{</span>
  <span class="c1">/// &lt;summary&gt;Co-ordinates&lt;/summary&gt;</span>
  <span class="k">private</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span></code></pre>

<p>While the above may not be a best example in terms of programming, it does illustrate the fact that even a doc comment can affect more than one class member though, of course, in terms of the chemical tree, the two declared fields are collected under the umbrella of an <code class="code highlight language-text">IMultipleFieldDeclaration</code>.</p>

<p>So now let’s get back to the usual questions. First, how do you determine that the caret is on a doc comment? The same way as before, except that the type of the node is different:</p>

<pre><code class="code-block__wrapper code-block _highlighted lang_csharp"><span class="kt">bool</span> <span class="n">isOnDocComment</span> <span class="p">=</span> <span class="n">provider</span><span class="p">.</span><span class="n">TokenAfterCaret</span> <span class="k">is</span> <span class="n">IDocCommentNode</span><span class="p">;</span></code></pre>

<p>Now, you could always try and replace the doc comment wholesale (just like we did with simple comments), but instead of calling <code class="code highlight language-text">CreateComment()</code> on a <code class="code highlight language-text">CSharpElementFactory</code>, you have two separate methods that you can call for creating doc comments:</p>

<ul>
  <li><code class="code highlight language-text">CreateDocComment()</code> expects no line breaks in the specified parameter and simply prefixes the text with a <code class="code highlight language-text">///</code>.</li>
  <li><code class="code highlight language-text">CreateDocCommentBlock()</code> actually splits the parameters you provide into separate lines and then adds each one of them as part of a large block. Each line is, of course, prefixed with <code class="code highlight language-text">///</code>.</li>
</ul>

<p>The above methods may appear useful, but they have nothing to do with XML whatsoever. If you’re after manipulating XML, there’s an entirely different set of structures that you have to use.</p>

<a name="xml-doc-comment-editing" class="elem-anchor"></a>
<h3>XML Doc Comment Editing<a href="#xml-doc-comment-editing" class="anchor-link"><span></span></a></h3>

<p>Replacing the doc comment block completely is a pretty bad idea, because in most cases it’s up to you to keep the XML structure consistent. As a result, there’s a better way.</p>

<p>First of all, it’s worth explaining what the <em>block</em> part in <code class="code highlight language-text">XmlCommentBlock</code> means. Essentially, a block is simply a collection of XML comment nodes that sit next to one another. For example, you might have a <code class="code highlight language-text">&lt;summary&gt;</code> on one line and a <code class="code highlight language-text">&lt;param&gt;</code> on another: these lines together form part of a block.</p>

<p>A single doc comment is then part of that block. For example, a <code class="code highlight language-text">&lt;summary&gt;</code> would be a separate <code class="code highlight language-text">IDocCommentNode</code> that is part of a larger <code class="code highlight language-text">IDocCommentBlockNode</code>. Please note that a <code class="code highlight language-text">IDocCommentBlockNode</code> is created even if there is only one <code class="code highlight language-text">DocComment</code> in it.</p>

<p>Unlike basic comments, doc comment blocks are language-specific. This means that, if you’re working with C#, you’ll most likely be working with an <code class="code highlight language-text">ICSharpDocCommentBlockNode</code>. This type of node is a lot more interesting because, unlike the typical XML doc-related API which would yield you a simple <code class="code highlight language-text">XmlNode</code> (see e.g., the <code class="code highlight language-text">IDeclaration.GetXmlDoc()</code> method), the <code class="code highlight language-text">ICSharpDocCommentBlockNode</code> can yield you a fully fledged XML PSI interface:</p>

<pre><code class="code-block__wrapper code-block _highlighted lang_csharp"><span class="kt">var</span> <span class="n">node</span> <span class="p">=</span> <span class="n">provider</span><span class="p">.</span><span class="n">TokenAfterCaret</span><span class="p">.</span><span class="n">Parent</span> <span class="k">as</span> <span class="n">ICSharpDocCommentBlockNode</span><span class="p">;</span>
<span class="n">IDocCommentXmlPsi</span> <span class="n">xmlPsi</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="n">GetXmlPsi</span><span class="p">();</span></code></pre>

<p>Note the use of <code class="code highlight language-text">Parent</code> property in the above call: your caret is, essentially, on a doc comment node, whose <em>parent</em> is the block.</p>

<p>The great thing about <code class="code highlight language-text">IDocCommentXmlPsi</code> is that it contains a myriad of utility methods for adding or modifying particular XML doc declarations such as summary, parameters, exception information, and so on. For example, the following piece of code lets you add a <code class="code highlight language-text">&lt;summary&gt;</code> to the block comment:</p>

<pre><code class="code-block__wrapper code-block _highlighted lang_csharp"><span class="kt">var</span> <span class="n">factory</span> <span class="p">=</span> <span class="n">XmlElementFactory</span><span class="p">.</span><span class="n">GetInstance</span><span class="p">&lt;</span><span class="n">XmlDocLanguage</span><span class="p">&gt;();</span>
<span class="kt">var</span> <span class="n">summaryTag</span> <span class="p">=</span> <span class="n">factory</span><span class="p">.</span><span class="n">CreateTag</span><span class="p">(</span><span class="s">&quot;&lt;summary&gt;this method rocks&lt;/summary&gt;&quot;</span><span class="p">);</span>
<span class="n">xmlPsi</span><span class="p">.</span><span class="n">AddSummaryNode</span><span class="p">(</span><span class="n">summaryTag</span><span class="p">);</span></code></pre>

<p>Please note that the XML PSI interface is only available on <em>existing</em> XML doc comment blocks - you cannot get this interface if you have an ordinary comment <code class="code highlight language-text">/// like this one</code> in your code. Thus, if you need to create an XML doc comment block from scratch, you should first use a <code class="code highlight language-text">CSharpElementFactory</code> to create the initial content for the block, and then get the <code class="code highlight language-text">IDocCommentXmlPsi</code> interface from it.</p>



                    <div class="last-modified">
                        Last modified: 8 May 2015
                    </div>
                </article>

                <section class="disqus">
                    <div id="disqus_thread"></div>
                </section>
            </div>
        </section>
    </main>
</div>


<script data-main="/resharper/devguide/app/js/main.build" data-baseurl="/resharper/devguide/" src="/resharper/devguide/app/js/vendor/requirejs/require.js"></script>

</body>
</html>

