


<!doctype html>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <title> / ReSharper  DevGuide</title>
    <link rel="stylesheet" href="/resharper-devguide/app/css/styles.min.css">
<link  rel="stylesheet" href="/resharper-devguide/styles/styles.css"></head>
<body data-id="Platform/Lifetime/CaseStudy">
<div class="wrapper">
    <section class="panel _nav">
        <header class="panel__header">
            <div class="container">
                <form class="search-box">
                    <label for="search-box__input" class="search-box__label">
                        <input type="text" class="search-box__input" id="search-box__input" placeholder="Search ReSharper  DevGuide">
                    </label>
                    <div class="search-box__clear" title="Clear"></div>
                </form>
            </div>
        </header>
        <nav class="panel__content">
            <div class="container _nav">
                <menu class="nav-tree"></menu>
            </div>
            <div class="container _footer panel__footer">
                <p><a href="mailto:feedback@jetbrains.com">Send feedback</a></p>
                <p>&copy; 2000&ndash;2015 <a href="//www.jetbrains.com">JetBrains</a> s.r.o.<br>
                    All rights reserved.</p>
            </div>
        </nav>
    </section>

    <main class="panel _main" role="main">
        <header class="panel__header">
            <div class="container">
                <h3>ReSharper DevGuide</h3>
                
        <div class="shortcuts-switcher"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1">
            <option data-group="primary" value="default" selected>Default</option>
            <option data-group="primary" value="default_for_gnome">GNOME</option>
            <option data-group="primary" value="default_for_kde">KDE</option>
            <option data-group="primary" value="default_for_xwin">XWindow</option>
            <option data-group="primary" value="emacs">Emacs</option>
            <option data-group="primary" value="jbuilder">JBuilder</option>
            <option data-group="primary" value="visual_studio">Visual Studio</option>
            <option data-group="primary" value="netbeans_6.5">NetBeans 6.5</option>
            <option data-group="primary" value="eclipse">Eclipse</option>
            <option data-group="secondary" value="mac_os_x_10.5_">OS X 10.5+</option>
            <option data-group="secondary" value="mac_os_x">OS X</option>
            <option data-group="secondary" value="eclipse_mac_os_x">OS X Eclipse</option></select>
        </div>
    
                <div class="panel-trigger"></div>
            </div>
        </header>
        <section class="panel__content">
            <div class="container">
                <article class="article" data-shortcut-switcher="false">

                    
                    <a name="case-study" class="elem-anchor"></a>
<h1>Case Study<a href="#case-study" class="anchor-link"><span></span></a></h1>

<aside class="note">
  <p> This topic refers to the implementation of the Extension Manager for ReSharper 8. This implementation has changed for ReSharper 9 and no longer matches this description. However, the described behaviour is still a very valid usage of the <code class="code highlight language-text">Lifetime</code> classes.</p>
</aside>

<p><code class="code highlight language-text">Lifetime</code> is a very powerful concept. Normal usage is very straight forward, either by adding a simple callback, or passing it to an API. Generally speaking, this is how it will be used day to day.</p>

<p>However, it can also be used to help manage more complex scenarios.</p>

<p>Let’s take a deeper look at one such example. Consider ReSharper’s Extension Manager. Extensions can be installed and uninstalled at any time. They can also be disabled and enabled, and there are also thread affinity concerns. <code class="code highlight language-text">Lifetime</code> really helps keep the code manageable.</p>

<a name="loading-extensions" class="elem-anchor"></a>
<h2>Loading Extensions<a href="#loading-extensions" class="anchor-link"><span></span></a></h2>

<p>Since extensions can be uninstalled at any time, it makes sense that they have a <code class="code highlight language-text">Lifetime</code>. If an extension is uninstalled, its <code class="code highlight language-text">Lifetime</code> is terminated. Any registered actions will be run and any nested <code class="code highlight language-text">Lifetimes</code> will also be terminated.</p>

<a name="settings-files" class="elem-anchor"></a>
<h2>Settings Files<a href="#settings-files" class="anchor-link"><span></span></a></h2>

<p>When an extension is first loaded, the <code class="code highlight language-text">ExtensionSettingsLoader</code> class looks to see if it contains any settings files. If so, it calls into the Settings subsystem to load the files. The files are loaded with a <code class="code highlight language-text">Lifetime</code> instance, and the Settings subsystem will register a callback that removes the settings file when that <code class="code highlight language-text">Lifetime</code> terminates.</p>

<aside class="note">
  <p> Note that there is no code to explicitly remove settings files. It is automatically handled by nested <code class="code highlight language-text">Lifetime</code>s and the settings subsystem adding cleanup code to the given <code class="code highlight language-text">Lifetime</code>.</p>
</aside>

<p>However, we also want to remove settings files when the extension is disabled. So, instead of calling the Settings subsystem with the extension’s own <code class="code highlight language-text">Lifetime</code>, <code class="code highlight language-text">ExtensionSettingsLoader</code> creates a new <code class="code highlight language-text">Lifetime</code> that is valid for the duration that an extension is enabled. Since this is a consecutive, non-overlapping duration, the settings loader uses an instance of <code class="code highlight language-text">SequentialLifetimes</code> to manage this.</p>

<p>When the extension is enabled, <code class="code highlight language-text">SequentialLifetimes.Next</code> is called to create a new <code class="code highlight language-text">Lifetime</code>, and this can be passed to the Settings subsystem when loading the files. When the extension is disabled, <code class="code highlight language-text">SequentialLifetimes.TerminateCurrent</code> causes this settings file <code class="code highlight language-text">Lifetime</code> to be terminated, running the Settings subsystem’s callback, which removes the files.</p>

<p>Since <code class="code highlight language-text">SequentialLifetimes</code> creates a nested <code class="code highlight language-text">Lifetime</code> with the extension’s own <code class="code highlight language-text">Lifetime</code> as the parent, when the extension is uninstalled, this parent <code class="code highlight language-text">Lifetime</code> terminates, which terminates the nested <code class="code highlight language-text">Lifetime</code>, and the settings files are automatically removed.</p>

<a name="enforcing-thread-affinity" class="elem-anchor"></a>
<h2>Enforcing Thread Affinity<a href="#enforcing-thread-affinity" class="anchor-link"><span></span></a></h2>

<p>To further complicate matters, there is a thread affinity issue here. When adding a settings file, it must be done on the main thread, since the list of settings layers are used as-is for binding to WPF (a design flaw, admittedly) and if they’re not added on the main thread, WPF throws an exception. This requires the call into the <code class="code highlight language-text">Settings</code> subsystem to be enqueued to run on the main thread.</p>

<p>However, we now run the risk of a race condition - if we enqueue an action to add the settings file on the main thread, it’s possible that the extension is disabled or even uninstalled before the settings files can be loaded.</p>

<p>Fortunately, we can use a <code class="code highlight language-text">Lifetime</code> when enqueuing the add action to the UI thread. We can use the <code class="code highlight language-text">Lifetime</code> created by the <code class="code highlight language-text">SequentialLifetimes</code> for this. If the extension is disabled, or uninstalled, the <code class="code highlight language-text">SequentialLifetimes</code> class will terminate the <code class="code highlight language-text">Lifetime</code> and the queued action is not executed.</p>

<a name="removing-settings-files" class="elem-anchor"></a>
<h2>Removing Settings Files<a href="#removing-settings-files" class="anchor-link"><span></span></a></h2>

<p>Removing the settings files is also complicated by the thread affinity issue.</p>

<p><code class="code highlight language-text">Lifetime</code> instances are not multi-threaded. That is, their callbacks are executed on the same thread that terminated the <code class="code highlight language-text">Lifetime</code>. If there are nested <code class="code highlight language-text">Lifetime</code> instances, then all callbacks of both the parent and the children are are executed on the same thread.</p>

<p>So, we can’t add the settings files with a <code class="code highlight language-text">Lifetime</code> that is a child of either the extension’s own <code class="code highlight language-text">Lifetime</code>, or the <code class="code highlight language-text">SequentialLifetimes</code> class; if either of these terminate, then the callback is executed on the same thread that terminated it. This means the Settings subsystem will try to remove the settings on the same thread that either uninstalled or disabled the extension, and this is not necessarily the UI thread.</p>

<p><code class="code highlight language-text">Lifetime</code> doesn’t provide any threading facilities, so we need to manage this ourselves. The answer is fairly straightforward though - create a new, unnested <code class="code highlight language-text">Lifetime</code> (it’s parent is <code class="code highlight language-text">EternalLifetime.Instance</code>) and use it to load the settings file. This <code class="code highlight language-text">Lifetime</code> is later explicitly terminated on the UI thread, by registering a callback with the <code class="code highlight language-text">SequentialLifetimes</code> instance that calls <code class="code highlight language-text">LifetimeDefinition.Terminate</code>.</p>

<p>The final thing to consider is the <code class="code highlight language-text">Lifetime</code> used to enqueue the terminate action to the UI thread. Since this only happens when a <code class="code highlight language-text">Lifetime</code> is terminated, we can’t use any existing <code class="code highlight language-text">Lifetime</code> instances (they’ve been terminated - the action wouldn’t happen!), so in this case, we use <code class="code highlight language-text">EternalLifetime.Instance</code> - we always want this to happen, because no-one else can terminate that unnested <code class="code highlight language-text">Lifetime</code>. We also know that the action will be executed, and removed from the <code class="code highlight language-text">EternalLifetime</code> instance, so there’s no memory leak.</p>

<a name="summary" class="elem-anchor"></a>
<h2>Summary<a href="#summary" class="anchor-link"><span></span></a></h2>

<p>This means we have three <code class="code highlight language-text">Lifetime</code> objects on the go.</p>

<ul>
  <li>Firstly, the extension’s own <code class="code highlight language-text">Lifetime</code>. This is the main parent <code class="code highlight language-text">Lifetime</code>. If it’s terminated, all other <code class="code highlight language-text">Lifetime</code> objects are also terminated.</li>
  <li>Secondly, we have a <code class="code highlight language-text">Lifetime</code> created by the <code class="code highlight language-text">SequentialLifetimes</code> object every time the extension is enabled, and terminated when it’s disabled. This is used to enqueue a call to the main thread, and also used to register a callback to explicitly terminate the third <code class="code highlight language-text">Lifetime</code>.</li>
  <li>The third <code class="code highlight language-text">Lifetime</code> is an un-nested <code class="code highlight language-text">Lifetime</code> that is passed to the <code class="code highlight language-text">Settings</code> subsystem. Terminating this is what causes the settings files to be unloaded. This <code class="code highlight language-text">Lifetime</code> is explicitly terminated on the UI thread. The terminate action is enqeued to the UI thread with the <code class="code highlight language-text">EternalLifetime</code> to ensure it actually happens.</li>
</ul>

<p>We now have a system of adding and removing the settings files when the extension’s <code class="code highlight language-text">Enabled</code> property changes. We also add and remove the settings files on the main thread, and don’t add the settings files if the extension has been disabled before the main thread was available to run the command. Finally, everything is removed when the extension is uninstalled.</p>

<p>Consider implementing these same requirements with <code class="code highlight language-text">IDisposable</code>.</p>

<ul>
  <li>Firstly, we would need to know when the extension was being uninstalled, which <code class="code highlight language-text">IDisposable</code> wouldn’t give us. (We would need to register with some event, presumably exposed by the extension itself)</li>
  <li>Secondly, we would have to manage state to know if the files were currently loaded or not in the Settings subsystem and update this when the extension’s enabled state changed.</li>
  <li>Thirdly, we would have to manage enqueuing to the main thread, and work around the race condition of disabling the extension before adding the files.</li>
  <li>Finally, we would have to explicitly tell the Settings subsystem to unload the settings files when either the extension was removed, or made disabled.</li>
</ul>

<p><code class="code highlight language-text">Lifetime</code> manages a lot of state for us in this situation.</p>



                    <div class="last-modified">
                        Last modified: 8 May 2015
                    </div>
                </article>

                <section class="disqus">
                    <div id="disqus_thread"></div>
                </section>
            </div>
        </section>
    </main>
</div>


<script data-main="/resharper-devguide/app/js/main.build" data-baseurl="/resharper-devguide/" src="/resharper-devguide/app/js/vendor/requirejs/require.js"></script>

</body>
</html>

