


<!doctype html>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <title> / ReSharper  DevGuide</title>
    <link rel="stylesheet" href="/resharper/devguide/app/css/styles.min.css">
<link  rel="stylesheet" href="/resharper/devguide/styles/styles.css"></head>
<body data-id="Platform/VisualStudio/ComponentModel">
<div class="wrapper">
    <section class="panel _nav">
        <header class="panel__header">
            <div class="container">
                <form class="search-box">
                    <label for="search-box__input" class="search-box__label">
                        <input type="text" class="search-box__input" id="search-box__input" placeholder="Search ReSharper  DevGuide">
                    </label>
                    <div class="search-box__clear" title="Clear"></div>
                </form>
            </div>
        </header>
        <nav class="panel__content">
            <div class="container _nav">
                <menu class="nav-tree"></menu>
            </div>
            <div class="container _footer panel__footer">
                <p><a href="mailto:feedback@jetbrains.com">Send feedback</a></p>
                <p>&copy; 2000&ndash;2015 <a href="//www.jetbrains.com">JetBrains</a> s.r.o.<br>
                    All rights reserved.</p>
            </div>
        </nav>
    </section>

    <main class="panel _main" role="main">
        <header class="panel__header">
            <div class="container">
                <h3>ReSharper DevGuide</h3>
                
        <div class="shortcuts-switcher"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1">
            <option data-group="primary" value="default" selected>Default</option>
            <option data-group="primary" value="default_for_gnome">GNOME</option>
            <option data-group="primary" value="default_for_kde">KDE</option>
            <option data-group="primary" value="default_for_xwin">XWindow</option>
            <option data-group="primary" value="emacs">Emacs</option>
            <option data-group="primary" value="jbuilder">JBuilder</option>
            <option data-group="primary" value="visual_studio">Visual Studio</option>
            <option data-group="primary" value="netbeans_6.5">NetBeans 6.5</option>
            <option data-group="primary" value="eclipse">Eclipse</option>
            <option data-group="secondary" value="mac_os_x_10.5_">OS X 10.5+</option>
            <option data-group="secondary" value="mac_os_x">OS X</option>
            <option data-group="secondary" value="eclipse_mac_os_x">OS X Eclipse</option></select>
        </div>
    
                <div class="panel-trigger"></div>
            </div>
        </header>
        <section class="panel__content">
            <div class="container">
                <article class="article" data-shortcut-switcher="false">

                    
                    <a name="component-model-and-visual-studio-interfaces" class="elem-anchor"></a>
<h1>Component Model and Visual Studio interfaces<a href="#component-model-and-visual-studio-interfaces" class="anchor-link"><span></span></a></h1>

<aside class="warning">
  <p> This topic relates to ReSharper 8, and has not been updated to ReSharper 9 or the ReSharper Platform.</p>
</aside>

<p>The Component Model also allows access to interfaces implemented by Visual Studio. However, it is recommended that you try and avoid the use of Visual Studio interfaces, as this usually ties your plugin to a particular version of Visual Studio, and requires the plugin to run in the Visual Studio hosted version of ReSharper. Your plugin won’t run in the Command Line Tools version of ReSharper. You are strongly encouraged to use ReSharper interfaces and services whenever possible.</p>

<p>If you still need to get an interface implemented by Visual Studio, or by a Visual Studio extension, you can do this in several ways. The easiest is to simply inject the interface as a constructor parameter to your plugin component, or retrieve it from the Shell’s container. For example, to get to VS’s Output Window interface <code class="code highlight language-text">IVsOutputWindow</code>, you can acquire it with the following:</p>

<pre><code class="code-block__wrapper code-block _highlighted lang_csharp"><span class="n">Shell</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Lazy</span><span class="p">&lt;</span><span class="n">IVsOutputWindow</span><span class="p">&gt;&gt;()</span></code></pre>

<p>Note the use of <code class="code highlight language-text">Lazy&lt;T&gt;</code>. Many of the Visual Studio interfaces can only be resolved using <code class="code highlight language-text">Lazy&lt;T&gt;</code>, to allow for delay loading VS packages and assemblies, or <code class="code highlight language-text">Optional&lt;T&gt;</code>, because there is no guarantee that interface is available - perhaps the required VS package isn’t installed.</p>

<p>It is recommended that you use <code class="code highlight language-text">Lazy</code> and <code class="code highlight language-text">Optional</code>. If the plugin is run outside of the Visual Studio environment (e.g. in the Command Line Tools), the Visual Studio dependencies will not be available. It is better for your component to handle this gracefully than for the Component Model to be unable to create your component. An alternative is to mark your component as only being able to run in the Visual Studio environment, by passing in the <code class="code highlight language-text">ProgramConfigurations.VS_ADDIN</code> flag to the component attribute. However, this can have a “viral” effect. If this component isn’t created because you’re not running inside Visual Studio, any other component that depends on this must also include the <code class="code highlight language-text">VS_ADDIN</code> flag, or the Component Model will be unable to create it, also. A better solution is the use of <code class="code highlight language-text">Optional</code>, <code class="code highlight language-text">Lazy</code>, or perhaps moving the component into a Visual Studio specific assembly that is only loaded in the Visual Studio environment.</p>

<pre><code class="code-block__wrapper code-block _highlighted lang_csharp"><span class="na">[ShellComponent(ProgramConfigurations.VS_ADDIN)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">MyShellComponent</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="na">[SolutionComponent(ProgramConfigurations.VS_ADDIN)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">MySolutionComponent</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span></code></pre>

<p>ReSharper only exposes a subset of Visual Studio’s interfaces in this manner. In fact, the interfaces are only exposed to support ReSharper’s own integration with Visual Studio. In addition, some interfaces are wrapped, to ensure correct usage, e.g. wrapping parameters for COM interop, releasing returned COM intptr’s, checking returned <code class="code highlight language-text">HRESULT</code>s, etc. You should consult the whitelist below to see what interfaces are available. If it’s there, you can consume it via a component’s constructor.</p>

<p>If you need to access interfaces that aren’t exposed, you have two options:</p>

<ol>
  <li>Get access to the <code class="code highlight language-text">Microsoft.VisualStudio.OLE.Interop.IServiceProvider</code> interface, and request it yourself</li>
  <li>Set up a class to expose the required interfaces from the container</li>
</ol>

<a name="retrieving-interfaces-from-iserviceprovider" class="elem-anchor"></a>
<h2>Retrieving interfaces from IServiceProvider<a href="#retrieving-interfaces-from-iserviceprovider" class="anchor-link"><span></span></a></h2>

<p>First, it’s important to note that there are several <code class="code highlight language-text">IServiceProvider</code> types in the CLR. We are interested in <code class="code highlight language-text">Microsoft.VisualStudio.OLE.Interop.IServiceProvider</code>, which is a COM interface.</p>

<p>The Component Model explicitly bans this interface. If you try and consume <code class="code highlight language-text">IServiceProvider</code> in your constructor, ReSharper will throw an exception, and tell you to use the <code class="code highlight language-text">JetBrains.VsIntegration.Application.RawVsServiceProvider</code> wrapper class. The purpose of this class is to ensure that you know you are deliberately bypassing ReSharper and talking directly to Visual Studio. This isn’t a recommended solution, but is sometimes necessary. Make sure you know what you are doing. You should always try and use either a ReSharper interface, or request the Visual Studio interface from ReSharper first - remember that ReSharper wraps some Visual Studio interfaces.</p>

<p>Once you have the <code class="code highlight language-text">RawVsServiceProvider</code> class, you can simply use the <code class="code highlight language-text">Value</code> property to get access to the interface, and query Visual Studio for a specific service. It is now your responsibility to ensure the interface is called correctly, and any COM requirements are met.</p>

<a name="expose-interfaces-to-the-container" class="elem-anchor"></a>
<h2>Expose interfaces to the container<a href="#expose-interfaces-to-the-container" class="anchor-link"><span></span></a></h2>

<p>You can implement a class that will be called by ReSharper during initialisation that can register additional Visual Studio interfaces. It needs to be marked with the <code class="code highlight language-text">WrapVsInterfaces</code> attribute, and implement the <code class="code highlight language-text">IExposeVsServices</code> interface:</p>

<pre><code class="code-block__wrapper code-block _highlighted lang_csharp"><span class="na">[WrapVsInterfaces]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">ExposeMyServices</span> <span class="p">:</span> <span class="n">IExposeVsServices</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">Register</span><span class="p">(</span><span class="n">VsServiceProviderComponentContainer</span><span class="p">.</span><span class="n">VsServiceMap</span> <span class="n">map</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// For example:</span>
    <span class="c1">// map.QueryService&lt;SComponentModel&gt;.As&lt;IComponentModel&gt;();</span>
    <span class="c1">// or map.Mef&lt;IOutliningManagerService&gt;();</span>
    <span class="c1">// or map.OptionalMef&lt;IOutliningManagerService&gt;();</span>
    <span class="c1">// or map.Wrapper(interface =&gt; GetInterestingInterface(map, interface));</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>This class allows you to expose one or more interfaces that comes from a service. The first example gets the <code class="code highlight language-text">IComponentModel</code> interface from the MEF <code class="code highlight language-text">SComponentModel</code> service, allowing you to call <code class="code highlight language-text">IComponentModel.GetService</code> to retrieve a service exposed by MEF. The next two examples show an easier way of doing this, by adding support for a particular MEF exposed interface. The <code class="code highlight language-text">OptionalMef</code> call is the same as the <code class="code highlight language-text">Mef</code> call, but requires the interface to be wrapped in <code class="code highlight language-text">Optional&lt;T&gt;</code>, or it won’t be found. Finally, the Wrapper method calls a custom function to resolve the interface. Use of this method is discouraged.</p>

<p>One important thing to note is that you can only register an interface once. If there are two plugins both registering the same interface, only the first registration (arbitrarily chosen) will be used. The second is ignored. So it is important not to do anything “fancy” in a custom function - it might never get called! Also, while the second registration is ignored and the registration method completes successfully, ReSharper handles and logs an exception. Since these exceptions are displayed to the user in the exception reporter, it is a good practice to check if the interface is already registered before trying to register yourself. You can use the following extension method to do this (and doesn’t interfere with lazy instantiation):</p>

<pre><code class="code-block__wrapper code-block _highlighted lang_csharp"><span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="n">IsRegistered</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">VsServiceProviderComponentContainer</span><span class="p">.</span><span class="n">VsServiceMap</span> <span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">map</span><span class="p">.</span><span class="n">Resolve</span><span class="p">(</span><span class="k">typeof</span> <span class="p">(</span><span class="n">T</span><span class="p">))</span> <span class="p">!=</span> <span class="k">null</span><span class="p">;</span>
<span class="p">}</span></code></pre>

<p>These interfaces are now exposed to ReSharper’s container, and can be injected into the constructor, or retrieved via the Shell’s <code class="code highlight language-text">GetComponent</code> method.</p>

<p>You should use <code class="code highlight language-text">Lazy&lt;TInterface&gt;</code> when consuming a Visual Studio interface, so that Visual Studio packages are not loaded until they are used. For example, accepting a parameter of <code class="code highlight language-text">IEditorOperationsFactoryService</code> will cause the VS editor to be loaded into memory as soon as your plugin is loaded, which is at application startup, rather than when the editor is first needed, which might be after a solution has loaded.</p>

<p>If you expect the interface to not be available, you can use <code class="code highlight language-text">Optional&lt;TInterface&gt;</code> in your constructor. You can even combine the two <code class="code highlight language-text">Lazy&lt;Optional&lt;T&gt;&gt;</code> which will defer resolving the underlying service until you need it, and allow it to be missing.</p>

<p>When using <code class="code highlight language-text">map.QueryService</code>, you can enforce requiring these flags by using the <code class="code highlight language-text">LazyOnly</code> and/or <code class="code highlight language-text">Optional</code> methods. If a component tries to consume the service without <code class="code highlight language-text">Lazy&lt;T&gt;</code> or <code class="code highlight language-text">Optional&lt;T&gt;</code> respectively, the Component Model will throw an exception.</p>

<pre><code class="code-block__wrapper code-block _highlighted lang_csharp"><span class="k">public</span> <span class="k">void</span> <span class="nf">Register</span><span class="p">(</span><span class="n">VsServiceProviderComponentContainer</span><span class="p">.</span><span class="n">VsServiceMap</span> <span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">map</span><span class="p">.</span><span class="n">QueryService</span><span class="p">&lt;</span><span class="n">STextTemplating</span><span class="p">&gt;.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">ITextTemplatingEngineHost</span><span class="p">&gt;.</span><span class="n">LazyOnly</span><span class="p">().</span><span class="n">Optional</span><span class="p">();</span>
<span class="p">}</span></code></pre>

<p>The <code class="code highlight language-text">Mef</code> and <code class="code highlight language-text">OptionalMef</code> methods register the interface as <code class="code highlight language-text">LazyOnly</code>, so you can <em>only</em> get it if you request <code class="code highlight language-text">Lazy&lt;TMefInterface&gt;</code>. If there is a chance that the MEF interface will not be available, you should register it with the <code class="code highlight language-text">OptionalMef</code> method, and consume it as <code class="code highlight language-text">Lazy&lt;Optional&lt;T&gt;&gt;</code>.</p>

<a name="default-list-of-exposed-interfaces" class="elem-anchor"></a>
<h2>Default list of exposed interfaces<a href="#default-list-of-exposed-interfaces" class="anchor-link"><span></span></a></h2>

<p>For ReSharper 8, the default whitelist of supported interfaces is as follows:</p>

<ul>
  <li><code class="code highlight language-text">IVsSolutionBuildManager</code>, <code class="code highlight language-text">IVsSolutionBuildManager2</code>, <code class="code highlight language-text">IVsSolutionBuildManager3</code></li>
  <li><code class="code highlight language-text">IVsTrackProjectDocuments2</code></li>
  <li><code class="code highlight language-text">IVsTextManager</code>, <code class="code highlight language-text">IVsTextManager2</code>, <code class="code highlight language-text">IVsHiddenTextManager</code></li>
  <li><code class="code highlight language-text">ILocalRegistry</code>, <code class="code highlight language-text">ILocalRegistry2</code></li>
  <li><code class="code highlight language-text">IOleComponentManager</code></li>
  <li><code class="code highlight language-text">IVsUIShell</code>, <code class="code highlight language-text">IVsUIShell2</code></li>
  <li><code class="code highlight language-text">Help</code>, <code class="code highlight language-text">Help2</code></li>
  <li><code class="code highlight language-text">IVsProfferCommands</code>, <code class="code highlight language-text">IVsProfferCommands2</code>, <code class="code highlight language-text">IVsProfferCommands3</code></li>
  <li><code class="code highlight language-text">IVsFontAndColorCacheManager</code></li>
  <li><code class="code highlight language-text">IVsQueryEditQuerySave2</code></li>
  <li><code class="code highlight language-text">IVsCodeDefView</code></li>
  <li><code class="code highlight language-text">IVsDebugger</code>, <code class="code highlight language-text">IVsDebugger2</code> (Lazy only)</li>
  <li><code class="code highlight language-text">DTE</code>, <code class="code highlight language-text">DTE2</code></li>
  <li><code class="code highlight language-text">IVsCmdNameMapping</code></li>
  <li><code class="code highlight language-text">IProfferService</code></li>
  <li><code class="code highlight language-text">IUIHostLocale</code></li>
  <li><code class="code highlight language-text">IVsAppCommandLine</code></li>
  <li><code class="code highlight language-text">IVsClassView</code></li>
  <li><code class="code highlight language-text">IVsExternalFilesManager</code></li>
  <li><code class="code highlight language-text">IVsFileChangeEx</code></li>
  <li><code class="code highlight language-text">IVsFontAndColorStorage</code></li>
  <li><code class="code highlight language-text">IVsLaunchPad</code>, <code class="code highlight language-text">IVsLaunchPad2</code></li>
  <li><code class="code highlight language-text">IVsLinkedUndoTransactionManager</code></li>
  <li><code class="code highlight language-text">IVsObjBrowser</code> (Lazy only)</li>
  <li><code class="code highlight language-text">IVsObjectManager2</code> (Lazy only)</li>
  <li><code class="code highlight language-text">IVsOutputWindow</code> (Lazy only)</li>
  <li><code class="code highlight language-text">IVsRegisterEditors</code></li>
  <li><code class="code highlight language-text">IVsRegisterPriorityCommandTarget</code></li>
  <li><code class="code highlight language-text">IVsSolution</code></li>
  <li><code class="code highlight language-text">IVsUIShellOpenDocument</code></li>
  <li><code class="code highlight language-text">IVsWebBrowsingService</code></li>
  <li><code class="code highlight language-text">IVsActivityLog</code></li>
  <li><code class="code highlight language-text">IVsExtensibility3</code></li>
  <li><code class="code highlight language-text">IVsWebProxy</code></li>
</ul>

<p>Also, the following interfaces are exposed when running in Visual Studio 2010:</p>

<ul>
  <li><code class="code highlight language-text">IVsEditorAdaptersFactoryService</code></li>
  <li><code class="code highlight language-text">IOutliningManagerService</code></li>
  <li><code class="code highlight language-text">IEditorOperationsFactoryService</code></li>
  <li><code class="code highlight language-text">IClassificationTypeRegistryService</code></li>
  <li><code class="code highlight language-text">IClassificationFormatMapService</code></li>
  <li><code class="code highlight language-text">IViewTagAggregatorFactoryService</code></li>
  <li><code class="code highlight language-text">IIncrementalSearchFactroyService</code></li>
  <li><code class="code highlight language-text">IVsSolution4</code></li>
  <li><code class="code highlight language-text">IVsUIShell4</code></li>
  <li><code class="code highlight language-text">IVsThreadedWaitDialogFactory</code></li>
  <li><code class="code highlight language-text">IVsBuildManagerAccessor</code></li>
  <li><code class="code highlight language-text">IVsFindManagerHelper</code></li>
  <li><code class="code highlight language-text">IVsPackageInstallerServices</code> (Lazy/Optional only)</li>
  <li><code class="code highlight language-text">IVsPackageInstallerEvents</code> (Lazy/Optional only)</li>
  <li><code class="code highlight language-text">IVsPackageInstaller</code> (Lazy/Optional only)</li>
  <li><code class="code highlight language-text">IVsPackageUninstaller</code> (Lazy/Optional only)</li>
</ul>

<p>And Visual Studio 2012:</p>

<ul>
  <li><code class="code highlight language-text">IVsTaskSchedulerService</code></li>
  <li><code class="code highlight language-text">IVsUIShell5</code></li>
  <li><code class="code highlight language-text">IVsFileChangeExPrivate</code></li>
  <li><code class="code highlight language-text">IVsAppContainerProjectDeploy</code></li>
  <li><code class="code highlight language-text">IVsDebugger4</code></li>
</ul>

<p>And Visual Studio 2013:</p>

<ul>
  <li><code class="code highlight language-text">IPeekBroker</code> (Lazy/Optional only)</li>
</ul>

<p>Furthermore, the following classes are used instead of accessing the VS interfaces directly:</p>

<ul>
  <li><code class="code highlight language-text">RawVsServiceProvider</code> (<code class="code highlight language-text">IServiceProvider</code> - use advisedly!)</li>
  <li><code class="code highlight language-text">JetBrains.VsIntegration.Interop.Shim.Shell.IVsMonitorSelection</code></li>
  <li><code class="code highlight language-text">Interop.Shim.Shell.IVsRunningDocumentTable</code></li>
  <li><code class="code highlight language-text">Interop.Shim.Shell.IVsShell</code></li>
  <li><code class="code highlight language-text">JetBrains.VsIntegration.Application.VsUIHostCommandDispatcher</code> (<code class="code highlight language-text">SUIHostCommandDispatcher</code>’s <code class="code highlight language-text">IOleCommandTarget</code>)</li>
</ul>



                    <div class="last-modified">
                        Last modified: 8 May 2015
                    </div>
                </article>

                <section class="disqus">
                    <div id="disqus_thread"></div>
                </section>
            </div>
        </section>
    </main>
</div>


<script data-main="/resharper/devguide/app/js/main.build" data-baseurl="/resharper/devguide/" src="/resharper/devguide/app/js/vendor/requirejs/require.js"></script>

</body>
</html>

