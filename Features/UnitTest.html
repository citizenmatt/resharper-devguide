


<!doctype html>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <title> / ReSharper  DevGuide</title>
    <link rel="stylesheet" href="/resharper/devguide/app/css/styles.min.css">
<link  rel="stylesheet" href="/resharper/devguide/styles/styles.css"></head>
<body data-id="Features/UnitTest">
<div class="wrapper">
    <section class="panel _nav">
        <header class="panel__header">
            <div class="container">
                <form class="search-box">
                    <label for="search-box__input" class="search-box__label">
                        <input type="text" class="search-box__input" id="search-box__input" placeholder="Search ReSharper  DevGuide">
                    </label>
                    <div class="search-box__clear" title="Clear"></div>
                </form>
            </div>
        </header>
        <nav class="panel__content">
            <div class="container _nav">
                <menu class="nav-tree"></menu>
            </div>
            <div class="container _footer panel__footer">
                <p><a href="mailto:feedback@jetbrains.com">Send feedback</a></p>
                <p>&copy; 2000&ndash;2015 <a href="//www.jetbrains.com">JetBrains</a> s.r.o.<br>
                    All rights reserved.</p>
            </div>
        </nav>
    </section>

    <main class="panel _main" role="main">
        <header class="panel__header">
            <div class="container">
                <h3>ReSharper DevGuide</h3>
                
        <div class="shortcuts-switcher"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1">
            <option data-group="primary" value="default" selected>Default</option>
            <option data-group="primary" value="default_for_gnome">GNOME</option>
            <option data-group="primary" value="default_for_kde">KDE</option>
            <option data-group="primary" value="default_for_xwin">XWindow</option>
            <option data-group="primary" value="emacs">Emacs</option>
            <option data-group="primary" value="jbuilder">JBuilder</option>
            <option data-group="primary" value="visual_studio">Visual Studio</option>
            <option data-group="primary" value="netbeans_6.5">NetBeans 6.5</option>
            <option data-group="primary" value="eclipse">Eclipse</option>
            <option data-group="secondary" value="mac_os_x_10.5_">OS X 10.5+</option>
            <option data-group="secondary" value="mac_os_x">OS X</option>
            <option data-group="secondary" value="eclipse_mac_os_x">OS X Eclipse</option></select>
        </div>
    
                <div class="panel-trigger"></div>
            </div>
        </header>
        <section class="panel__content">
            <div class="container">
                <article class="article" data-shortcut-switcher="false">

                    
                    <a name="unit-test-framework-support" class="elem-anchor"></a>
<h1>Unit Test Framework Support<a href="#unit-test-framework-support" class="anchor-link"><span></span></a></h1>

<aside class="warning">
  <p> This topic relates to ReSharper 8, and has not been updated to ReSharper 9 or the ReSharper Platform.</p>
</aside>

<p>Most of ReSharper plugins involve support for different unit test frameworks. This page describes ways in which you can add unit test support to your own framework.</p>

<a name="overview" class="elem-anchor"></a>
<h2>Overview<a href="#overview" class="anchor-link"><span></span></a></h2>

<p>The first thing you need to understand about ReSharper testing is the way in which ReSharper actually <em>finds</em> tests. One would expect that the way of finding tests in ReSharper is by simply traversing the PSI (i.e., the syntax tree from parsed source code) looking for the appropriate attributes. However, on large solutions, this is too slow, which is why another approach exists: traversing the compiled assemblies and acquiring test information from there.</p>

<p>As a result, plugin writers need to support two separate test analysers - the metadata explorer and the file explorer.</p>

<a name="metadata-explorer" class="elem-anchor"></a>
<h3>Metadata Explorer<a href="#metadata-explorer" class="anchor-link"><span></span></a></h3>

<p>The metadata explorer is used to explore the metadata of compiled CLR assemblies to look for test elements. It is not applicable to non-CLR unit test frameworks such as QUnit.</p>

<p>In order to support the metadata explorer, plugin writers need to create a class decorated by the <code class="code highlight language-text">[MetadataUnitTestExplorer]</code> interface and implementing the <code class="code highlight language-text">IUnitTestMetadataExplorer</code> interface. This interface has two members:</p>

<ul>
  <li>The <code class="code highlight language-text">Provider</code> property, which returns the unit test provider.</li>
  <li>The <code class="code highlight language-text">ExploreAssembly()</code> method, which is used to tell an explorer to explore the metadata for a particular assembly.</li>
</ul>

<a name="file-explorer" class="elem-anchor"></a>
<h3>File Explorer<a href="#file-explorer" class="anchor-link"><span></span></a></h3>

<p>The file explorer acts in a way similar to the metadata explorer, the only difference being that instead of an <code class="code highlight language-text">ExploreAssembly()</code> method it has an <code class="code highlight language-text">ExploreFile()</code> method which, predictably, takes an <code class="code highlight language-text">IFile</code> to explore.</p>

<p>A typical implementation of the <code class="code highlight language-text">ExploreFile()</code> method is to simply take the file and call <code class="code highlight language-text">ProcessDescendants()</code> on it, passing your own file explorer class which implements the <code class="code highlight language-text">IRecursiveElementProcessor</code> interface. From then on, the idea is to traverse the PSI tree of the file (just like you would if you were writing an ordinary analyzer), identify the elements which constitute test fixtures, tests, and so on, and then construct appropriate <code class="code highlight language-text">IUnitTestElement</code> entities.</p>

<a name="iunittestelement" class="elem-anchor"></a>
<h3>IUnitTestElement<a href="#iunittestelement" class="anchor-link"><span></span></a></h3>

<p>The <code class="code highlight language-text">IUnitTestElement</code> interface is the core interface that is involved in unit testing. Essentially, this interface needs to be implemented by any class in your code that <em>represents</em> a test.</p>

<p>Currently, ReSharper currently has several base classes for test elements, such as <code class="code highlight language-text">MsTestElementBase</code> or <code class="code highlight language-text">NUnitElementBase</code>. These elements are further subclassed by the <em>form</em> in which a test element appears. Some examples are:</p>

<ul>
  <li>A fixture</li>
  <li>A method</li>
  <li>A row or test case</li>
</ul>

<p>Other elements can be created to suit your needs. For example, if your tests are defined in fields, you could create a <code class="code highlight language-text">SomeFrameworkElementBase</code> that implements <code class="code highlight language-text">IUnitTestElement</code> and subsequently derive from it your <code class="code highlight language-text">SomeFrameworkFieldElement</code> class.</p>

<p>If you look at the existing implementations of <code class="code highlight language-text">XxxElementBase</code> classes, you will notice that each one of them takes a <code class="code highlight language-text">XxxTestProvider</code> as a parameter to be injected in the constructor. (This provider is also returned in the <code class="code highlight language-text">Provider</code> property.) This provider class is the class which actually explores the assembly and creates the tie-in between ReSharper and the unit testing framework of choice.</p>

<a name="iunittestprovider" class="elem-anchor"></a>
<h3>IUnitTestProvider<a href="#iunittestprovider" class="anchor-link"><span></span></a></h3>

<p>The unit test provider is a class which implements the <code class="code highlight language-text">IUnitTestProvider</code> interface and is decorated with the <code class="code highlight language-text">[UnitTestProvider]</code> attribute. The actual binding of the provider to a particular element happens in the <code class="code highlight language-text">IsElementOfKind()</code> method. This method is used to determine whether the particular element is, in fact, an element of a particular kind. The possible kinds, which are part of the <code class="code highlight language-text">UnitTestElementKind</code> enumeration, are as follows:</p>

<ul>
  <li>Unknown – we don’t know what this is</li>
  <li>Test – the actual test which does does something. Here we mean something like a <code class="code highlight language-text">[Test]</code> or a <code class="code highlight language-text">[TestCase]</code> – both count as tests.</li>
  <li>TestContainer – this represents a container of a set of tests. Typically, this matches a <code class="code highlight language-text">[TestFixture]</code>, but if we have a test with several rows/test cases, then this would also cover a <code class="code highlight language-text">[Test]</code>.</li>
  <li>TestStuff – this is any element which relates to tests, such as all of the aforementioned elements plus elements such as <code class="code highlight language-text">[SetUpFixture]</code></li>
</ul>

<p>There are, in fact, two overloads of <code class="code highlight language-text">IsElementKindOf()</code>. One takes an <code class="code highlight language-text">IDeclaredElement</code>, whereas another atakes a <code class="code highlight language-text">IUnitTestElement</code>. The overload that takes an <code class="code highlight language-text">IUnitTestElement</code> is simple – it simply implements a set of rules similar to the list above, for example:</p>

<pre><code class="code-block__wrapper code-block _highlighted lang_csharp"><span class="k">public</span> <span class="kt">bool</span> <span class="nf">IsElementOfKind</span><span class="p">(</span><span class="n">IUnitTestElement</span> <span class="n">element</span><span class="p">,</span> <span class="n">UnitTestElementKind</span> <span class="n">elementKind</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">elementKind</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="n">UnitTestElementKind</span><span class="p">.</span><span class="n">Unknown</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">!(</span><span class="n">element</span> <span class="k">is</span> <span class="n">NUnitElementBase</span><span class="p">);</span>
    <span class="k">case</span> <span class="n">UnitTestElementKind</span><span class="p">.</span><span class="n">Test</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">element</span> <span class="k">is</span> <span class="n">NUnitTestElement</span> <span class="p">||</span> <span class="n">element</span> <span class="k">is</span> <span class="n">NUnitRowTestElement</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">UnitTestElementKind</span><span class="p">.</span><span class="n">TestContainer</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">element</span> <span class="k">is</span> <span class="n">NUnitTestFixtureElement</span> <span class="p">||</span> <span class="n">element</span> <span class="k">is</span> <span class="n">NUnitSetUpFixtureElement</span> <span class="p">||</span> <span class="p">(</span><span class="n">element</span> <span class="k">is</span> <span class="n">NUnitElementBase</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">element</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="n">IsEmpty</span><span class="p">())</span> <span class="p">||</span> <span class="n">element</span> <span class="k">is</span> <span class="n">NUnitTestFromAbstractFixtureFakeElement</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">UnitTestElementKind</span><span class="p">.</span><span class="n">TestStuff</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">element</span> <span class="k">is</span> <span class="n">NUnitElementBase</span><span class="p">;</span>
    <span class="k">default</span><span class="p">:</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentOutOfRangeException</span><span class="p">(</span><span class="s">&quot;elementKind&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>The overload taking an IDeclaredElement is a bit more complicated. Essentially, this overload checks for the <code class="code highlight language-text">UnitTestElementKind</code> on the actual code element. As a result, it is the responsibility of the developer to check that this is indeed the case.</p>

<p>Here’s an example. Let’s suppose that we want to determine whether something is a unit test. This would imply that our <code class="code highlight language-text">IDeclaredElement</code> is:</p>

<ul>
  <li>An <code class="code highlight language-text">ITypeMember</code></li>
  <li>An <code class="code highlight language-text">IMethod</code>, since NUnit tests are kept in methods</li>
  <li>Is public and not abstract</li>
  <li>Is not generic</li>
  <li>Has any attribute (direct or derived) from a set containing <code class="code highlight language-text">Test</code>, <code class="code highlight language-text">TestCase</code>, etc.</li>
</ul>

<p>In order to determine whether a particular attribute has been applied to a method, we create declarations similar to the following</p>

<pre><code class="code-block__wrapper code-block _highlighted lang_csharp"><span class="n">IClrTypeName</span> <span class="n">TestAttribute</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ClrTypeName</span><span class="p">(</span><span class="s">&quot;NUnit.Framework.TestAttribute&quot;</span><span class="p">);</span></code></pre>

<p>and we subsequently check that the attribute owner (i.e. our method) has this attribute using the <code class="code highlight language-text">HasInstanceAttribute()</code> method. Determining <em>derived</em> types is a bit more complicated – take a look at the <code class="code highlight language-text">UnitTestAttributeCache</code> class in ReSharper for an illustration of how this is handled.</p>

<a name="remoterecursivetaskrunner" class="elem-anchor"></a>
<h3>RemoteRecursiveTaskRunner<a href="#remoterecursivetaskrunner" class="anchor-link"><span></span></a></h3>

<p>We now come to what is arguably the most complicated part of all: the task runner which actually runs the unit tests. This class typically inherits from <code class="code highlight language-text">RecursiveRemoteTaskRunner</code> and is expected to implement several methods from its parent types. Let’s take a look at some of them.</p>

<p>The <code class="code highlight language-text">ConfigureAppDomain()</code> method is used to configure the <code class="code highlight language-text">AppDomain</code> for running the tests. This method takes a <code class="code highlight language-text">TaskAppDomainConfiguration</code> object and is expected to modify it, setting things like the priority or the apartment state. Some of these settings can be read from the configuration file (see <code class="code highlight language-text">NUnitTaskRunner</code> for an example).</p>

<p>The <code class="code highlight language-text">ExecuteRecursive()</code> method is the method that actually executes the tasks.</p>

<p>If you peek into the <code class="code highlight language-text">NUnitTaskRunner</code>, you may see something strange: infrastructure code being acquired from resources and compiled before test execution. Please note that this approach is only necessary if you want one version of your plugin to support many versions of your unit test framework. (And, even if you do that, you will have problems because of changing APIs.) Thus, if you are making a plugin for your own unit test framework, your best bet is to simply keep the test framework and the plugin in sync, i.e. release plugins that correspond to your unit test framework versions</p>

<a name="row-test-support" class="elem-anchor"></a>
<h3>Row Test Support<a href="#row-test-support" class="anchor-link"><span></span></a></h3>

<p>Most test frameworks provide support for parameterised tests, usually in the form of a test method that takes parameters, and is called multiple times by the test framework’s runner. NUnit’s parameterised tests look like this:</p>

<pre><code class="code-block__wrapper code-block _highlighted lang_csharp"><span class="na">[TestCase(12, 3, 4)]</span>
<span class="na">[TestCase(12, 2, 6)]</span>
<span class="na">[TestCase(12, 4, 3)]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">DivideTest</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Assert</span><span class="p">.</span><span class="n">AreEqual</span><span class="p">(</span> <span class="n">q</span><span class="p">,</span> <span class="n">n</span> <span class="p">/</span> <span class="n">d</span> <span class="p">);</span>
<span class="p">}</span></code></pre>

<p>or like this:</p>

<pre><code class="code-block__wrapper code-block _highlighted lang_csharp"><span class="na">[TestFixture]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">MyTests</span>
<span class="p">{</span>
<span class="na">  [Test, TestCaseSource(typeof(MyFactoryClass),&quot;TestCases&quot;)]</span>
  <span class="k">public</span> <span class="kt">int</span> <span class="nf">DivideTest</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">/</span><span class="n">d</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">MyFactoryClass</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span> <span class="n">TestCases</span>
  <span class="p">{</span>
    <span class="k">get</span>
    <span class="p">{</span>
      <span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">TestCaseData</span><span class="p">(</span><span class="m">12</span><span class="p">,</span> <span class="m">3</span><span class="p">).</span><span class="n">Returns</span><span class="p">(</span><span class="m">4</span><span class="p">);</span>
      <span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">TestCaseData</span><span class="p">(</span><span class="m">12</span><span class="p">,</span> <span class="m">2</span><span class="p">).</span><span class="n">Returns</span><span class="p">(</span><span class="m">6</span><span class="p">);</span>
      <span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">TestCaseData</span><span class="p">(</span><span class="m">12</span><span class="p">,</span> <span class="m">4</span><span class="p">).</span><span class="n">Returns</span><span class="p">(</span><span class="m">3</span><span class="p">);</span>
      <span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">TestCaseData</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
        <span class="p">.</span><span class="n">Throws</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">DivideByZeroException</span><span class="p">))</span>
        <span class="p">.</span><span class="n">SetName</span><span class="p">(</span><span class="s">&quot;DivideByZero&quot;</span><span class="p">)</span>
        <span class="p">.</span><span class="n">SetDescription</span><span class="p">(</span><span class="s">&quot;An exception is expected&quot;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>The main difference here is that in the first example, all rows are known at edit/compile time, while in the second example, the rows are essentially dynamic - the implementation of <code class="code highlight language-text">TestCases</code> can return any number of rows, potentially different each time the test is run.</p>

<p>Row tests are handled by providing another implementation of <code class="code highlight language-text">IUnitTestElement</code>. Conceptually, you would have a test fixture element that represented test classes. It’s <code class="code highlight language-text">Children</code> property contains test method elements, and each test method can optionally have any number of row test elements in its <code class="code highlight language-text">Children</code> property. (Strictly speaking, ReSharper can support arbitrary levels of test elements, so you can represent assembly fixtures or other tasks that need to run before test classes, test methods and row tests).</p>

<p>The implementation of the row test element is very similar to the test method and test class elements:</p>

<ul>
  <li>If you can identify the row test from the source, then you should add row tests when parsing the file looking for elements, just as you would for test classes and test methods. You should try and reuse elements so that ReSharper can maintain state in the test runner window (and especially important for multiple runs with dotCover). So, use a predictable id for the element, and check to see if it already exists by calling <code class="code highlight language-text">IUnitTestElementManager.GetElementById</code>. If it does exist, update anything that needs updating (e.g. set the state to <code class="code highlight language-text">UnitTestElementState.Valid</code>). If it doesn’t exist, create it and give it to the element consumer while parsing the file.</li>
  <li>Make sure your <code class="code highlight language-text">UnitTestElementComparer</code> knows how to compare row test elements.</li>
  <li>Make sure <code class="code highlight language-text">IUnitTestProvider.IsElementOfKind</code> knows how to handle row test elements.</li>
  <li>Make sure <code class="code highlight language-text">IUnitTestSerializer</code> knows how to serialise and deserialise row test elements.</li>
  <li>Make sure your row test element implements <code class="code highlight language-text">IUnitTestElement.GetTaskSequence</code> to return a list of tasks representing how to run that particular row test. This essentially means calling the row test’s <code class="code highlight language-text">Parent.GetTaskSequence</code> and appending a new instance of a class that derives from <code class="code highlight language-text">RemoteTask</code> and represents this row test. Again, this is important for dotCover code coverage.</li>
</ul>

<p>In your test runner, when your test framework reports that a row test is executing, try to find the task instance, and report progress to ReSharper in the normal manner.</p>

<p>If you don’t know the row tests in advance, but they are instead discovered at run time, you can still work with ReSharper. In your test runner, when you encounter a test that you don’t have a task for, you create your row test <code class="code highlight language-text">RemoteTask</code> instance and call <code class="code highlight language-text">IRemoteTaskServer.CreateDynamicElement(task)</code>. Then use the task as normal to report that the test is starting, skipped, passed or failed. If you do have tasks available, make sure they are used, rather than always creating a new task. This is especially important when working with dotCover.</p>

<p>On the server side, ReSharper will try to create a new element for that task. It does this by checking to see if your <code class="code highlight language-text">IUnitTestProvider</code> implements <code class="code highlight language-text">IDynamicUnitTestProvider</code>. If so, it will call <code class="code highlight language-text">IDynamicUnitTestProvider.GetDynamicElement</code>, passing in the task your runner created. It also passes in a dictionary of <code class="code highlight language-text">RemoteTask</code> to <code class="code highlight language-text">IUnitTestElement</code>, representing all of the tasks and elements that are present in the run. You should now:</p>

<ul>
  <li>Using information in the <code class="code highlight language-text">RemoteTask</code> your runner created, look for the parent task that represents the row test’s test method in the dictionary of tasks. You will need to check the type of the <code class="code highlight language-text">RemoteTask</code>, downcast and verify that the task represents the parent test method (e.g. you might need to check method name, type name and even assembly location). This will give you the task to lookup the <code class="code highlight language-text">IUnitTestElement</code> of the row test’s parent in the passed in dictionary.</li>
  <li>Get a read lock so that it is safe to read the PSI and project model ( <code class="code highlight language-text">using(ReadLockCookie.Create())...</code> )</li>
  <li>Create the same predictable id for the row test element, and try to get it from the <code class="code highlight language-text">IUnitTestElementManager.GetElementById</code>. If you get one, make sure to set the state to <code class="code highlight language-text">UnitTestElement.Dynamic</code> and reset the <code class="code highlight language-text">Parent</code> property to be the parent test method element. This is necessary for random row tests - it might not have been part of the last test run, so wouldn’t have been included in the task sequence. However, it might have run previously, and the <code class="code highlight language-text">UnitTestElementManager</code> might still have a handle to it, but might have marked it invalid, ready for clean up.</li>
  <li>If you don’t get an existing element, create a new one, and return it. It is important that if you are creating a row test element due to a dynamic request, that the <code class="code highlight language-text">IUnitTestElement.State</code> property is set to <code class="code highlight language-text">UnitTestElementState.Dynamic</code>, so ReSharper knows how to clean the element up on subsequent runs.</li>
</ul>



                    <div class="last-modified">
                        Last modified: 8 May 2015
                    </div>
                </article>

                <section class="disqus">
                    <div id="disqus_thread"></div>
                </section>
            </div>
        </section>
    </main>
</div>


<script data-main="/resharper/devguide/app/js/main.build" data-baseurl="/resharper/devguide/" src="/resharper/devguide/app/js/vendor/requirejs/require.js"></script>

</body>
</html>

